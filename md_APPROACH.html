<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pcms: Generic Core Edge Coupling Proceedure</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pcms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Generic Core Edge Coupling Proceedure </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In the current design we think of the coupling problem as coupling two groups of "solvers". Each solver is either an internal data computation or as a callback to an external code. For example, three solvers in the GENE/XGC electrostatic case are 1) GENE compute charge density, 2) XGC compute charge density, 3) XGC field solve for electric field.</p>
<p>Solvers are grouped based on the data transfer needs and a group is typically formed for each high level step in the coupling. In our concrete example we have the following two groups: 1) compute the charge density and 2) compute the electric field.</p>
<p>The reconciliation process transfers field data from one solver group to another. The field data is received from the first solver group and combined into a single unified field on the internal intermediate representation, ostensibly Omega_h, the unified field is converted to, and sent in the native format for the second solver group.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Basic pseudocode</h1>
<pre class="fragment">// example SolverGroupA is push operation and SolverGroupB is FieldSolve
Function reconcile(SolverGroupA, SolverGroupB)
    Receive native data for all solvers in SolverGroupA data (core/edge or field-solve)
    FieldTransfer native data for all solvers in SolverGroupA data to Internal(omega_h) mesh
    Construct unified field data on Internal (e.g. take care of buffer/overlap regions)
    FieldTransfer Internal field to SolverGroupB
    Send native data to SolverGroupB

Function solve(SolverGroup)
    asynchronously launch solver for each solver in SolverGroup
    wait for results

Function run_coupling(Coupling)
    solve(Core/Edge push)
    reconcile(core/edge, field solver)
    solve(field solver)
    // this loop is indicated for case where field solver is operating over multiple partitions and needs to reconcile data between them
    while (solver not converged) 
        reconcile(field solver,field solver)
        solve(field solver)
    reconcile(field solver, core/edge)


class Coupler {
    Coupler:
        Initialization (receive the mesh data and other initialization data)
    Run:
        while (not done coupling)
            // asyncrounously run each of the coupling steps
            run_coupling(charge density+electric field coupling) // poisson
            run_coupling(current density+parallel part of vector potential coupling) // ampere
            ...
            // wait for all of the coupling steps to complete
}
</pre> <h2><a class="anchor" id="autotoc_md2"></a>
Functions</h2>
<ol type="1">
<li>solve: launch the solver for the Core/Edge coupling this corresponds to either the push operation, or the field solve.</li>
<li>reconcile: Gets data from one solver's/coordinate system's and converts it to another's coordinate systems by way of intermediate representation</li>
<li>run_coupling: Takes solve and reconcile policy and performs the main control flow</li>
</ol>
<h2><a class="anchor" id="autotoc_md3"></a>
Classes/Concepts</h2>
<ol type="1">
<li>CoordinateSystem</li>
<li>Field</li>
<li>Solver</li>
<li>FieldTransfer</li>
<li>DataTransfer : how data transfer will happen for a given code</li>
<li>SolverGroup : group of solvers</li>
<li>Coupling : defines a complete coupling procedure for a given field/group of solvers e.g. this could be the charge density/poisson solve</li>
<li>Coupler : Ties together couplings, data initialization, etc to provide the full</li>
</ol>
<h2><a class="anchor" id="autotoc_md4"></a>
open questions</h2>
<ol type="1">
<li>For coupling with multiple fields should solve,reconcile, etc. deal with multiple fields internally? Or, run_coupling is run independently for each coupled set of fields? I think the cleaner approach is the latter where we run the coupling for each set of fields. If it becomes necessary later we can push the fields down the stack. Only problem I foresee is if there is some shared metadata or state. This may make parallel easier as we can launch the run_coupling for each coupled field on a new thread or process.</li>
<li>Design for async function calls. Clearly there is a lot of the design that must be done async and execute in parallel for any hope of efficiency. Question is how do we want to approach that? We can just dump stuff onto raw threads, look at sender/receiver impl. in HPX/reference impl, coroutines, futures, etc.</li>
<li>Who owns the state of the state of when the coupling is complete?</li>
</ol>
<h1><a class="anchor" id="autotoc_md5"></a>
Notes and things to consider</h1>
<ol type="1">
<li>Couplings may need to be performed at different rates.</li>
<li>Since couplings are performed asynchronously, then they must be orthogonal in the shared data they write to avoid race conditions.</li>
<li>Each solver in the solver group needs to also have a field transfer method to go to the internal representation. Needs to be part of the solver because each solver may have a different way of getting to the internal state. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
