# definitions for the Cray compiler family

MPFC = ftn
MPCC = cc
cmd=$(shell basename "`which $(MPFC) 2>/dev/null`")
ifneq ($(cmd),$(MPFC))
MPFC = crayftn
MPCC = craycc
endif

FC = ftn
CC = cc

MPI_MODDIR= 
MPI_LIBS = -lmpich
FFLAGS+=-D__CRAY__


ifeq ($(USE_PERFLIB),scalasca)
 MPFC := scalasca -instrument -user $(MPFC)
 MPCC := scalasca -instrument -user $(MPCC)
#	FFLAGS += -fpp -Wp,-P
endif
ifeq ($(USE_PERFLIB),ompp)
# the preprocessor must not write #line directives
# and also the quotes in the SVN statement is switched off
 MPFC := kinst-ompp $(MPFC)
 FC := kinst-ompp $(FC)
#	FFLAGS += -fpp -Wp,-P
endif

SET_FORTRAN_STANDARD =
PREPROC_FLAG = -e Z

DEBUG_TRACEBACK = -G0
DEBUG_FFLAGS = $(DEBUG_TRACEBACK) -eD
DEBUG_CFLAGS = 

ifneq ($(strip $(MKL_TARGET_ARCH)),)
 MKL_ARCH?=$(MKL_TARGET_ARCH)
endif
MKL_ARCH?=intel64

ifeq ($(CHIP),Core2)
 CHIP_OPT = -tp core2
endif
ifeq ($(CHIP),Nehalem)
 CHIP_OPT = -tp nehalem
endif
ifeq ($(CHIP),SandyBridge)
 CHIP_OPT = -tp sandybridge
endif
ifeq ($(CHIP),Phi)
 CHIP_OPT =
 MKL_ARCH = mic
endif

OPTLEVEL ?= 3
OPT_FFLAGS = -O$(OPTLEVEL) $(CHIP_OPT)
PRODRUN_FFLAGS = $(OPT_FFLAGS)
OPENMP_FFLAGS = -homp
ifneq ($(OPENMP),yes)
 FFLAGS += -xomp
# FFLAGS += -hnoomp
endif

SYMBOL_FFLAGS += -g 
SYMBOL_CFLAGS += -g

REPORT_FFLAGS = 

DOUBLE_PRECISION_FFLAGS = -s real64
DOUBLE_PRECISION_PREPREC = -D'erf=derf'

MODDIR_FFLAGS = # -J$(OBJDIR)

ifneq ($(MPIVENDOR),)
 MKLMPI = $(MPIVENDOR)
endif
ifeq ($(MKLMPI),bullxmpi)
 MKLMPI = openmpi
endif
MKLMPI ?= intelmpi

### CHECK WHETHER THE FOLLOWING WORKS WITH CRAYFTN ###
### ANYWAY, ON ALMOST ALL CRAY MACHINE LIBSCI IS USED INSTEAD ###
### SO THE MKL LINK LINE IS PROBABLY NOT REQUIRED ###
ifneq ($(MKLVERSION),10.1)
# Intel MKL >=10.3 sequential
 MKL_SCALAPACK_LINKLINE = $(MKLROOT)/lib/$(MKLARCH)/libmkl_scalapack_lp64.a \
	 -Wl,--start-group  $(MKLROOT)/lib/$(MKLARCH)/libmkl_gf_lp64.a \
	$(MKLROOT)/lib/$(MKLARCH)/libmkl_sequential.a \
	$(MKLROOT)/lib/$(MKLARCH)/libmkl_core.a \
	$(MKLROOT)/lib/$(MKLARCH)/libmkl_blacs_$(MKLMPI)_lp64.a \
	-Wl,--end-group -lpthread -lm
 MKL_FFLAGS = -m64 -I$(MKLROOT)/include

 MKL_BLAS_LINKLINE = -Wl,--start-group  $(MKLROOT)/lib/$(MKLARCH)/libmkl_gf_lp64.a \
	$(MKLROOT)/lib/$(MKLARCH)/libmkl_sequential.a \
	$(MKLROOT)/lib/$(MKLARCH)/libmkl_core.a \
	-Wl,--end-group -lpthread -lm
else
# Intel MKL 10.1 sequential
 MKL_ARCH = em64t
 MKL_SCALAPACK_LINKLINE = $(MKLROOT)/lib/$(MKLARCH)/libmkl_scalapack_lp64.a \
 	$(MKLROOT)/lib/$(MKLARCH)/libmkl_solver_lp64_sequential.a \
	-Wl,--start-group  $(MKLROOT)/lib/$(MKLARCH)/libmkl_gf_lp64.a \
	$(MKLROOT)/lib/$(MKLARCH)/libmkl_sequential.a \
	$(MKLROOT)/lib/$(MKLARCH)/libmkl_core.a \
	$(MKLROOT)/lib/$(MKLARCH)/libmkl_blacs_$(MKLMPI)_lp64.a \
	-Wl,--end-group -lpthread -lm

 MKL_FFLAGS = -m64 -I$(MKLROOT)/include

 MKL_BLAS_LINKLINE = $(MKLROOT)/lib/$(MKLARCH)/libmkl_solver_lp64_sequential.a \
 		   -Wl,--start-group  $(MKLROOT)/lib/$(MKLARCH)/libmkl_gf_lp64.a \
		   $(MKLROOT)/lib/$(MKLARCH)/libmkl_sequential.a \
		   $(MKLROOT)/lib/$(MKLARCH)/libmkl_core.a \
		   -Wl,--end-group -lpthread -lm
endif

F2003_MISSING=-DF2003_NO_OPEN_CONVERT

LDFLAGS += 
